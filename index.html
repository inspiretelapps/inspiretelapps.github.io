<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yeastar P-Series Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    
    <!-- PWA Manifest and Theme Color -->
    <!-- <link rel="manifest" href="manifest.json"> -->
    <meta name="theme-color" content="#ffffff">
    <link rel="apple-touch-icon" href="https://placehold.co/192x192/3498db/FFFFFF?text=PBX">
</head>
<body>

    <div class="container">
        <header>
            <h1>Yeastar Dashboard</h1>
            <label class="flex cursor-pointer gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><path d="M12 1v2M12 21v2M4.2 4.2l1.4 1.4M18.4 18.4l1.4 1.4M1 12h2M21 12h2M4.2 19.8l1.4-1.4M18.4 5.6l1.4-1.4"/></svg>
                <input type="checkbox" id="theme-toggle" class="toggle"/>
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
            </label>
        </header>

        <!-- API Configuration -->
        <div id="api-config-section" class="card">
            <h2>API Configuration</h2>
            <div class="form-group">
                <label for="proxy-url">Proxy URL</label>
                <input type="text" id="proxy-url" class="input" placeholder="https://your-proxy.herokuapp.com/">
            </div>
            <div class="form-group">
                <label for="pbx-host">PBX Host URL</label>
                <input type="text" id="pbx-host" class="input" placeholder="pbx.yeastarcloud.com">
            </div>
            <div class="form-group">
                <label for="client-id">Client ID</label>
                <input type="text" id="client-id" class="input" placeholder="Your Client ID">
            </div>
            <div class="form-group">
                <label for="client-secret">Client Secret</label>
                <input type="password" id="client-secret" class="input" placeholder="Your Client Secret">
            </div>
            <button id="connect-btn" class="btn btn-primary">Connect & Fetch Data</button>
            <button id="save-config-btn" class="btn btn-secondary">Save Config</button>
            <p style="font-size: 0.75rem; opacity: 0.7; margin-top: 1rem;">Note: Ensure the IP address of your proxy is whitelisted in your Yeastar PBX's API settings.</p>
        </div>

        <div id="dashboard-content" class="hidden">
            <!-- Today's Stats -->
            <div class="card">
                <h2>Today's Stats</h2>
                <div id="stats-loader">Loading...</div>
                <div id="stats-content" class="hidden">
                    <div id="overall-stats" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; text-align: center; margin-bottom: 1.5rem;">
                        <!-- Overall stats will be injected here -->
                    </div>
                    <div id="extension-stats">
                        <h3>Per Extension</h3>
                        <div style="overflow-x: auto;">
                            <table id="extension-stats-body">
                                <!-- Extension stats rows will be injected here -->
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Recent Calls -->
            <div class="card">
                <h2>Recent Calls</h2>
                <button id="refresh-recent" class="btn btn-secondary" style="margin-bottom: 1rem;">Refresh</button>
                <div id="recent-calls-loader">Loading...</div>
                <div id="recent-calls-content" class="hidden">
                    <!-- Recent calls will be injected here -->
                </div>
                <div id="recent-calls-pagination" class="hidden" style="display: flex; justify-content: center; gap: 1rem; margin-top: 1rem;">
                    <button id="prev-calls" class="btn" disabled>Previous</button>
                    <span id="page-info">Page 1</span>
                    <button id="next-calls" class="btn">Next</button>
                </div>
            </div>

            <!-- Quick Route Override -->
            <div class="card">
                <h2>Quick Route Override</h2>
                <p style="font-size: 0.875rem; opacity: 0.7; margin-bottom: 1rem;">Quickly change where calls go with preset options</p>
                <div id="quick-override-loader">Loading...</div>
                <div id="quick-override-content" class="hidden">
                    <!-- Quick override buttons will be injected here -->
                </div>
            </div>

            <!-- Route Switching System -->
            <div class="card">
                <h2>Route Switching System</h2>
                <p style="font-size: 0.875rem; opacity: 0.7; margin-bottom: 1rem;">Switch between predefined route configurations by changing route priorities</p>
                <div id="route-switching-loader">Loading...</div>
                <div id="route-switching-content" class="hidden">
                    <!-- Route switching controls will be injected here -->
                </div>
            </div>

            <!-- Advanced Inbound Route Management -->
            <div class="card">
                <h2>Advanced Inbound Route Management</h2>
                <div id="routing-loader">Loading...</div>
                <div id="routing-content" class="hidden">
                    <!-- Inbound routes will be injected here -->
                </div>
            </div>
        </div>

        <!-- Edit Route Modal -->
        <dialog id="edit-route-modal" class="modal">
            <div class="modal-box">
                <h3 id="edit-route-modal-title">Edit Inbound Route</h3>
                <form id="edit-route-form">
                    <input type="hidden" id="edit-route-id">
                    <div class="form-group">
                        <label for="simple-dest-select">Destination</label>
                        <select id="simple-dest-select" class="input"></select>
                    </div>
                    <div class="modal-action">
                        <button type="submit" class="btn btn-primary">Save Changes</button>
                        <button type="button" class="btn" onclick="document.getElementById('edit-route-modal').close()">Cancel</button>
                    </div>
                </form>
            </div>
        </dialog>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- THEME CONTROLLER ---
            const themeToggle = document.getElementById('theme-toggle');
            const htmlElement = document.documentElement;

            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (prefersDark) {
                htmlElement.classList.add('dark-mode');
                themeToggle.checked = true;
            }

            themeToggle.addEventListener('change', () => {
                htmlElement.classList.toggle('dark-mode');
            });

            // DOM Elements
            const proxyUrlInput = document.getElementById('proxy-url');
            const pbxHostInput = document.getElementById('pbx-host');
            const clientIdInput = document.getElementById('client-id');
            const clientSecretInput = document.getElementById('client-secret');
            const connectBtn = document.getElementById('connect-btn');
            const saveConfigBtn = document.getElementById('save-config-btn');
            const apiConfigSection = document.getElementById('api-config-section');
            const dashboardContent = document.getElementById('dashboard-content');
            const queueSelect = document.getElementById('queue-select');

            // Load saved config
            const savedConfig = JSON.parse(localStorage.getItem('yeastarConfig'));
            if (savedConfig) {
                proxyUrlInput.value = savedConfig.proxyUrl;
                pbxHostInput.value = savedConfig.host;
                clientIdInput.value = savedConfig.clientId;
                clientSecretInput.value = savedConfig.clientSecret;
            }

            // Global state
            let accessToken = sessionStorage.getItem('yeastar_accessToken');
            let pbxHost = '';
            let proxyUrl = '';
            let extensionMap = new Map();
            let extensionList = [];
            let ivrList = [];
            let queueList = [];
            
            // --- API HELPER ---
            async function apiRequest(endpoint, method = 'GET', body = null, isRetry = false) {
                if (!accessToken) {
                    if (isRetry) {
                        alert('Authentication failed. Please check your credentials and connect again.');
                        return null;
                    }
                    console.log("Access token missing, attempting to get a new one...");
                    const newAccessToken = await getAccessToken(pbxHostInput.value, clientIdInput.value, clientSecretInput.value);
                    if (newAccessToken) {
                        accessToken = newAccessToken;
                        return apiRequest(endpoint, method, body, true);
                    } else {
                        return null;
                    }
                }

                // Build the target URL for the proxy
                const targetUrl = `${pbxHost}/openapi/v1.0/${endpoint.split('?')[0]}`;
                const params = new URLSearchParams(endpoint.split('?')[1] || '');
                params.append('access_token', accessToken);
                
                // Use the new proxy format: proxyUrl + /api/proxy/ + targetUrl
                const finalUrl = `${proxyUrl}/api/proxy/${targetUrl}?${params.toString()}`;

                const options = {
                    method,
                    headers: {
                        'Content-Type': 'application/json',
                        'User-Agent': 'YeastarDashboardWebApp',
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                };
                if (body) {
                    options.body = JSON.stringify(body);
                }

                try {
                    const response = await fetch(finalUrl, options);
                    const responseText = await response.text();
                    if (endpoint.includes('update')) {
                        console.log('Raw update response for ' + endpoint + ':', responseText.substring(0, 500));
                    }
                    let responseData;
                    try {
                        responseData = JSON.parse(responseText);
                    } catch (e) {
                        console.error('Parse error for ' + endpoint + ':', e, 'Raw:', responseText.substring(0, 200));
                        throw new Error('PBX returned non-JSON for ' + endpoint + '. Raw: ' + responseText.substring(0, 200));
                    }
                    if (!responseData) {
                        throw new Error('PBX returned empty data for ' + endpoint);
                    }
                    
                    if (responseData.errcode === 10004 && !isRetry) { // Token expired
                        console.log("Token expired, refreshing...");
                        accessToken = null;
                        sessionStorage.removeItem('yeastar_accessToken');
                        return apiRequest(endpoint, method, body, true);
                    }

                    if (!response.ok || (responseData.errcode && responseData.errcode !== 0)) {
                        throw new Error(`API Error ${responseData.errcode}: ${responseData.errmsg}`);
                    }
                    return responseData;
                } catch (error) {
                    console.error(`Error in apiRequest for ${endpoint}:`, error);
                     if (error instanceof SyntaxError) {
                        alert('Failed to parse API response. This is likely a CORS proxy issue. Please click the "Activate API Proxy" link, request temporary access on that page, and then try connecting again.');
                    } else {
                        alert(`An error occurred while fetching data from ${endpoint}. ${error.message}`);
                    }
                    return null;
                }
            }
            
            // --- AUTHENTICATION ---
            async function getAccessToken(host, clientId, clientSecret) {
                const targetUrl = `${host}/openapi/v1.0/get_token`;
                const url = `${proxyUrl}/api/proxy/${targetUrl}`;
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'User-Agent': 'YeastarDashboardWebApp',
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        body: JSON.stringify({
                            username: clientId,
                            password: clientSecret
                        })
                    });
                    
                    const responseText = await response.text();
                    let data;
                    try {
                        data = JSON.parse(responseText);
                    } catch (e) {
                        console.error('Auth parse error:', responseText.substring(0, 200));
                        throw new Error('Proxy/PBX returned invalid response (not JSON). Raw: ' + responseText.substring(0, 200) + '. Test proxy separately.');
                    }

                    if (data.errcode === 0) {
                        sessionStorage.setItem('yeastar_accessToken', data.access_token);
                        return data.access_token;
                    } else {
                        throw new Error(`Auth failed: Error ${data.errcode}: ${data.errmsg || 'Unknown'}. Check creds/host.`);
                    }
                } catch (error) {
                    console.error('Error getting access token:', error);
                    alert(`Failed to get access token: ${error.message}. Please check Proxy URL (${proxyUrl}), credentials, and PBX Host URL (${pbxHost}). Use test-proxy.html for details.`);
                    return null;
                }
            }


            // --- DATA FETCHING AND RENDERING ---

            // 0. Trunk Status
            // async function fetchAndRenderTrunkStatus() {
            //     setLoader('trunk-status', true);
            //     const result = await apiRequest('trunk/list');
            //     if (result && result.errcode === 0) {
            //         renderTrunkStatus(result.data);
            //     } else {
            //         renderTrunkStatus([]);
            //     }
            //     setLoader('trunk-status', false);
            // }

            // function renderTrunkStatus(trunks) {
            //     const container = document.getElementById('trunk-status-content');
            //     container.innerHTML = '';
            //     if (!trunks || trunks.length === 0) {
            //         container.innerHTML = '<p>No trunks found.</p>';
            //         return;
            //     }

            //     const table = document.createElement('table');
            //     table.innerHTML = `
            //         <thead>
            //             <tr>
            //                 <th>Name</th>
            //                 <th>Type</th>
            //                 <th class="text-center">Status</th>
            //             </tr>
            //         </thead>
            //         <tbody>
            //         </tbody>
            //     `;
            //     const tbody = table.querySelector('tbody');
            //     trunks.forEach(trunk => {
            //         const row = `
            //             <tr>
            //                 <td>${trunk.name}</td>
            //                 <td>${trunk.type}</td>
            //                 <td class="text-center"><span class="badge ${getTrunkStatusBadge(trunk.status)}">${formatTrunkStatus(trunk.status)}</span></td>
            //             </tr>
            //         `;
            //         tbody.innerHTML += row;
            //     });
            //     container.appendChild(table);
            // }


            async function fetchAllExtensions() {
                const result = await apiRequest('extension/list?page_size=1000');
                if (result && result.data) {
                    extensionMap.clear();
                    result.data.forEach(ext => {
                        extensionMap.set(ext.number, ext.id);
                    });
                    return result.data.map(ext => ext.id);
                }
                return [];
            }

            // 1. Today's Stats
            async function fetchAndRenderStats(extensionIds) {
                setLoader('stats', true);
                
                if (extensionIds.length === 0) {
                    console.log("No extensions found to fetch stats for.");
                    renderStats([]);
                    setLoader('stats', false);
                    return;
                }

                const today = new Date();
                const year = today.getFullYear();
                const month = String(today.getMonth() + 1).padStart(2, '0');
                const day = String(today.getDate()).padStart(2, '0');

                const startTime = `${year}/${month}/${day} 00:00:00`;
                const endTime = `${year}/${month}/${day} 23:59:59`;

                const endpoint = `call_report/list?type=extcallstatistics&start_time=${encodeURIComponent(startTime)}&end_time=${encodeURIComponent(endTime)}&ext_id_list=${extensionIds.join(',')}`;
                const result = await apiRequest(endpoint);

                if (result && result.errcode === 0 && result.ext_call_statistics_list) {
                    renderStats(result.ext_call_statistics_list);
                } else {
                    console.error("Failed to fetch stats or no stats available:", result);
                    renderStats([]);
                }
                setLoader('stats', false);
            }

            function renderStats(stats) {
                let totalAnswered = 0;
                let totalDuration = 0;
                let totalMissed = 0;
                
                const extensionStatsBody = document.getElementById('extension-stats-body');
                extensionStatsBody.innerHTML = '';

                if (!stats || stats.length === 0) {
                    const row = `
                        <tr>
                            <td colspan="3" class="text-center">No call statistics for today.</td>
                        </tr>
                    `;
                    extensionStatsBody.innerHTML = row;
                } else {
                    stats.forEach(ext => {
                        const inboundAnswered = ext.inbound_answered_calls || 0;
                        const outboundAnswered = ext.outbound_answered_calls || 0;
                        const row = `
                            <tr>
                                <td>${ext.ext_name} (${ext.ext_num})</td>
                                <td class="text-center">${inboundAnswered}/${outboundAnswered}</td>
                                <td class="text-center">${formatDuration(ext.total_talking_time)}</td>
                            </tr>
                        `;
                        extensionStatsBody.innerHTML += row;

                        totalAnswered += ext.answered_calls;
                        totalDuration += ext.total_talking_time;
                        totalMissed += ext.missed_calls || 0;
                    });
                }

                const overallStatsContainer = document.getElementById('overall-stats');
                overallStatsContainer.innerHTML = `
                    <div>
                        <div>Total Answered</div>
                        <div>${totalAnswered}</div>
                    </div>
                    <div>
                        <div>Total Missed</div>
                        <div style="color: var(--color-error);">${totalMissed}</div>
                    </div>
                    <div>
                        <div>Total Duration</div>
                        <div>${formatDuration(totalDuration)}</div>
                    </div>
                `;
            }

            // 2. Inbound Routing
            async function fetchAndRenderInboundRoutes() {
                setLoader('routing', true);
                const result = await apiRequest('inbound_route/list?page_size=100');
                if (result && result.errcode === 0) {
                    renderInboundRoutes(result.data);
                } else {
                     renderInboundRoutes([]);
                }
                setLoader('routing', false);
            }

            function renderInboundRoutes(routes) {
                const container = document.getElementById('routing-content');
                container.innerHTML = '';
                 if (!routes || routes.length === 0) {
                    container.innerHTML = '<p>No inbound routes found.</p>';
                    return;
                }
                routes.forEach(route => {
                    const routeElement = document.createElement('div');
                    routeElement.style.backgroundColor = 'var(--color-base-200)';
                    routeElement.style.padding = '1rem';
                    routeElement.style.borderRadius = 'var(--radius)';

                    let destinationHTML = '';
                    if (route.time_condition === 'disabled' || !route.time_condition) {
                        const defaultDest = route.def_dest_value ||
                                          route.default_destination_value ||
                                          route.default_desination_value || // API typo
                                          route.destination_value ||
                                          'Not Set';
                        destinationHTML = `<p>Default: <span>${defaultDest}</span></p>`;
                    } else {
                         const businessHours = route.business_hours_destination_value ||
                                             route.bh_destination_value ||
                                             'Not Set';
                         const outsideHours = route.outside_business_hours_destination_value ||
                                            route.obh_destination_value ||
                                            'Not Set';
                         destinationHTML = `
                            <p>Office Hours: <span>${businessHours}</span></p>
                            <p>Outside Office Hours: <span>${outsideHours}</span></p>
                         `;
                    }

                    routeElement.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.75rem;">
                            <div>
                                <h4>${route.name}</h4>
                                ${destinationHTML}
                            </div>
                            <button class="btn" data-route-id="${route.id}">Edit</button>
                        </div>
                    `;
                    container.appendChild(routeElement);
                });
                 
                document.querySelectorAll('[data-route-id]').forEach(btn => {
                    btn.addEventListener('click', handleEditRoute);
                });
            }
            
            async function handleEditRoute(event) {
                const routeId = event.target.dataset.routeId;
                const modal = document.getElementById('edit-route-modal');
                document.getElementById('edit-route-id').value = routeId;

                const routeDetails = await apiRequest(`inbound_route/get?id=${routeId}`);
                console.log('Route details from API:', JSON.stringify(routeDetails, null, 2));
                if (!routeDetails || routeDetails.errcode !== 0) {
                    alert('Failed to fetch route details.');
                    return;
                }

                let menuOptions = { extension: [], ivr: [], queue: [], ring_group: [] };  // Fallback empty

                let allFailed = true;

                try {
                    // Fetch extensions directly
                    const extResult = await apiRequest('extension/list?page_size=100');
                    console.log('Extensions list result:', extResult);
                    if (extResult && extResult.errcode === 0) {
                        menuOptions.extension = (extResult.data || []).map(ext => ({
                            id: ext.id,
                            name: ext.display_name || ext.username || ('Ext ' + ext.number),  // Fix unnamed
                            number: ext.number
                        }));
                        allFailed = false;
                    } else {
                        console.warn('Extensions list failed:', extResult ? extResult.errmsg : 'No result');
                    }
                } catch (err) {
                    console.error('Extensions fetch error:', err);
                }

                try {
                    // Fetch IVRs
                    const ivrResult = await apiRequest('ivr/list?page_size=100');
                    console.log('IVRs list result:', ivrResult);
                    if (ivrResult && ivrResult.errcode === 0) {
                        menuOptions.ivr = (ivrResult.data || []).map(ivr => ({
                            id: ivr.id,
                            name: ivr.name || 'Unnamed IVR'
                        }));
                        allFailed = false;
                    } else {
                        console.warn('IVRs list failed:', ivrResult ? ivrResult.errmsg : 'No result');
                    }
                } catch (err) {
                    console.error('IVRs fetch error:', err);
                }

                try {
                    // Fetch Queues
                    const queueResult = await apiRequest('queue/list?page_size=100');
                    console.log('Queues list result:', queueResult);
                    if (queueResult && queueResult.errcode === 0) {
                        menuOptions.queue = (queueResult.data || []).map(q => ({
                            id: q.id,
                            name: q.name || 'Unnamed Queue'
                        }));
                        allFailed = false;
                    } else {
                        console.warn('Queues list failed:', queueResult ? queueResult.errmsg : 'No result');
                    }
                } catch (err) {
                    console.error('Queues fetch error:', err);
                }

                if (allFailed) {
                    alert('Unable to load destinations (extensions/IVRs/queues)—using empty options. Check PBX config and API access.');
                }

                console.log('Final menu options for routes:', menuOptions);

                populateDestinationSelects(menuOptions);

                const route = routeDetails.data;
                document.getElementById('edit-route-modal-title').textContent = `Edit: ${route.name}`;
                
                const simpleRadio = document.querySelector('input[name="routing-logic"][value="simple"]');
                const timeBasedRadio = document.querySelector('input[name="routing-logic"][value="time-based"]');

                if (route.time_condition === 'disabled') {
                    simpleRadio.checked = true;
                    document.getElementById('simple-destination-section').classList.remove('hidden');
                    document.getElementById('time-based-section').classList.add('hidden');
                    document.getElementById('simple-dest-select').value = `${route.def_dest}:${route.def_dest_value}`;
                } else {
                    timeBasedRadio.checked = true;
                    document.getElementById('simple-destination-section').classList.add('hidden');
                    document.getElementById('time-based-section').classList.remove('hidden');
                    document.getElementById('business-hours-dest-select').value = `${route.business_hours_destination}:${route.business_hours_destination_value}`;
                    document.getElementById('outside-business-hours-dest-select').value = `${route.outside_business_hours_destination}:${route.outside_business_hours_destination_value}`;
                    document.getElementById('holidays-dest-select').value = `${route.holidays_hours_destination}:${route.holidays_hours_destination_value}`;
                }

                modal.showModal();
            }

            function populateDestinationSelects(options) {
                const selects = [
                    document.getElementById('simple-dest-select'),
                    document.getElementById('business-hours-dest-select'),
                    document.getElementById('outside-business-hours-dest-select'),
                    document.getElementById('holidays-dest-select')
                ];

                selects.forEach(select => {
                    select.innerHTML = '<option value="none:">Not Set</option>';
                    if (options && Array.isArray(options.extension)) {
                        options.extension.forEach(ext => select.innerHTML += `<option value="extension:${ext.id}">${ext.name} (Ext: ${ext.number})</option>`);
                    }
                    if (options && Array.isArray(options.ivr)) {
                        options.ivr.forEach(ivr => select.innerHTML += `<option value="ivr:${ivr.id}">IVR: ${ivr.name}</option>`);
                    }
                    if (options && Array.isArray(options.queue)) {
                        options.queue.forEach(q => select.innerHTML += `<option value="queue:${q.id}">Queue: ${q.name}</option>`);
                    }
                });
            }

            document.getElementById('edit-route-form').addEventListener('submit', async (event) => {
                event.preventDefault();
                const routeId = document.getElementById('edit-route-id').value;

                const [dest, destValue] = document.getElementById('simple-dest-select').value.split(':');
                const payload = {
                    id: parseInt(routeId),
                    name: document.getElementById('edit-route-modal-title').textContent.replace('Edit: ', ''),
                    def_dest: dest,
                    def_dest_value: String(destValue || '')
                };

                try {
                    const result = await apiRequest('inbound_route/update', 'POST', payload);
                    if (result && result.errcode === 0) {
                        alert('Route updated successfully!');
                        document.getElementById('edit-route-modal').close();
                        fetchAndRenderInboundRoutes();
                        fetchAndRenderQuickOverride(); // Refresh quick override too
                    } else {
                        alert(`Failed to update route. Error: ${result ? result.errmsg : 'Unknown'}`);
                    }
                } catch (error) {
                    console.error('Update error:', error);
                    alert('Update failed: ' + error.message);
                }
            });

            // Quick Override functionality
            async function fetchAndRenderQuickOverride() {
                setLoader('quick-override', true);

                // Fetch all necessary data
                const [routeResult, extResult, ivrResult, queueResult] = await Promise.all([
                    apiRequest('inbound_route/list?page_size=100'),
                    apiRequest('extension/list?page_size=100'),
                    apiRequest('ivr/list?page_size=100'),
                    apiRequest('queue/list?page_size=100')
                ]);

                // Store data globally
                if (extResult && extResult.errcode === 0) {
                    extensionList = extResult.data || [];
                }
                if (ivrResult && ivrResult.errcode === 0) {
                    ivrList = ivrResult.data || [];
                }
                if (queueResult && queueResult.errcode === 0) {
                    queueList = queueResult.queue_list || queueResult.data || [];
                }

                if (routeResult && routeResult.errcode === 0) {
                    renderQuickOverride(routeResult.data);
                } else {
                    renderQuickOverride([]);
                }
                setLoader('quick-override', false);
            }

            function renderQuickOverride(routes) {
                const container = document.getElementById('quick-override-content');
                container.innerHTML = '';

                if (!routes || routes.length === 0) {
                    container.innerHTML = '<p>No inbound routes found.</p>';
                    return;
                }

                routes.forEach(route => {
                    console.log('Route data:', route); // Debug route data
                    const routeCard = document.createElement('div');
                    routeCard.style.backgroundColor = 'var(--color-base-200)';
                    routeCard.style.padding = '1rem';
                    routeCard.style.borderRadius = 'var(--radius)';
                    routeCard.style.marginBottom = '1rem';

                    // Improved destination handling with comprehensive field checking
                    let dest, destValue;
                    if (route.time_condition === 'disabled' || !route.time_condition) {
                        // Simple routing - check all possible field name variations
                        dest = route.def_dest || route.default_destination || route.destination;
                        destValue = route.def_dest_value ||
                                   route.default_destination_value ||
                                   route.default_desination_value || // API typo
                                   route.destination_value ||
                                   route.def_destination_value;
                    } else {
                        // Time-based routing - show primary destination with fallbacks
                        dest = route.business_hours_destination || route.bh_destination;
                        destValue = route.business_hours_destination_value ||
                                   route.bh_destination_value ||
                                   route.business_hours_dest_value;
                    }

                    const currentDest = getCurrentDestinationName(dest, destValue);
                    console.log('Route', route.name, '- time_condition:', route.time_condition, 'dest:', dest, 'destValue:', destValue, 'result:', currentDest);

                    const mainExt = extensionList.length > 0 ? extensionList[0] : null;
                    const mainIVR = ivrList.length > 0 ? ivrList[0] : null;

                    const mainExtLabel = mainExt ? `Ext ${mainExt.number}` : 'No Extensions';
                    const mainIVRLabel = mainIVR ? `${mainIVR.name}` : 'No IVRs';

                    routeCard.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                            <div>
                                <h4>${route.name}</h4>
                                <p style="font-size: 0.875rem; opacity: 0.7;">Currently: ${currentDest}</p>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.5rem;">
                            <button class="btn btn-success btn-sm" onclick="quickChangeRoute(${route.id}, 'extension', '${mainExt ? mainExt.id : '1'}')" ${!mainExt ? 'disabled' : ''}>${mainExtLabel}</button>
                            <button class="btn btn-info btn-sm" onclick="quickChangeRoute(${route.id}, 'ivr', '${mainIVR ? mainIVR.id : '1'}')" ${!mainIVR ? 'disabled' : ''}>${mainIVRLabel}</button>
                            <button class="btn btn-warning btn-sm" onclick="quickChangeRoute(${route.id}, 'ext_vm', '${mainExt ? mainExt.id : '1'}')" ${!mainExt ? 'disabled' : ''}>VM ${mainExt ? mainExt.number : 'N/A'}</button>
                            <button class="btn btn-error btn-sm" onclick="quickChangeRoute(${route.id}, 'end_call', '')">End Call</button>
                        </div>
                    `;
                    container.appendChild(routeCard);
                });
            }

            function getCurrentDestinationName(dest, destValue) {
                console.log('getCurrentDestinationName called with:', { dest, destValue, extensionList: extensionList.length, ivrList: ivrList.length });

                if (!dest) return 'No destination set';

                switch(dest) {
                    case 'extension': {
                        const ext = extensionList.find(e => e.id == destValue);
                        console.log('Extension lookup:', { destValue, found: ext });
                        return ext ? `Extension ${ext.number} (${ext.display_name || ext.username || 'Unnamed'})` : `Extension ${destValue}`;
                    }
                    case 'ivr': {
                        const ivr = ivrList.find(i => i.id == destValue);
                        console.log('IVR lookup:', { destValue, found: ivr });
                        return ivr ? `IVR: ${ivr.name}` : `IVR ${destValue}`;
                    }
                    case 'queue': {
                        const queue = queueList.find(q => q.id == destValue);
                        return queue ? `Queue: ${queue.name}` : `Queue ${destValue}`;
                    }
                    case 'ext_vm': {
                        const ext = extensionList.find(e => e.id == destValue);
                        return ext ? `Voicemail ${ext.number}` : `Voicemail ${destValue}`;
                    }
                    case 'end_call': return 'End Call';
                    default: return `${dest} ${destValue}`;
                }
            }

            function getMainExtension() {
                // Return the first extension ID from the list
                return extensionList.length > 0 ? extensionList[0].id : '1';
            }

            function getMainIVR() {
                // Return the first IVR ID from the list
                return ivrList.length > 0 ? ivrList[0].id : '1';
            }

            window.quickChangeRoute = async function(routeId, dest, destValue) {
                const payload = {
                    id: parseInt(routeId),
                    def_dest: dest,
                    def_dest_value: String(destValue)
                };

                try {
                    const result = await apiRequest('inbound_route/update', 'POST', payload);
                    if (result && result.errcode === 0) {
                        alert('Route changed successfully!');
                        fetchAndRenderQuickOverride();
                        fetchAndRenderInboundRoutes();
                    } else {
                        alert(`Failed to change route. Error: ${result ? result.errmsg : 'Unknown'}`);
                    }
                } catch (error) {
                    console.error('Quick change error:', error);
                    alert('Failed to change route: ' + error.message);
                }
            };

            // Route Switching System
            async function fetchAndRenderRouteSwitching() {
                setLoader('route-switching', true);
                const result = await apiRequest('inbound_route/list?page_size=100&sort_by=pos&order_by=asc');
                if (result && result.errcode === 0) {
                    renderRouteSwitching(result.data);
                } else {
                    renderRouteSwitching([]);
                }
                setLoader('route-switching', false);
            }

            function renderRouteSwitching(routes) {
                const container = document.getElementById('route-switching-content');
                container.innerHTML = '';

                if (!routes || routes.length === 0) {
                    container.innerHTML = '<p>No inbound routes found.</p>';
                    return;
                }

                console.log('Route switching - processing routes:', routes.length);

                // Group routes by DID pattern or similar criteria
                const routeGroups = groupRoutesByPattern(routes);
                console.log('Route switching - found groups:', Object.keys(routeGroups));

                Object.keys(routeGroups).forEach(pattern => {
                    const groupRoutes = routeGroups[pattern];
                    if (groupRoutes.length <= 1) return; // Skip single routes - no switching needed

                    const groupElement = document.createElement('div');
                    groupElement.style.backgroundColor = 'var(--color-base-200)';
                    groupElement.style.padding = '1rem';
                    groupElement.style.borderRadius = 'var(--radius)';
                    groupElement.style.marginBottom = '1rem';

                    // Find the currently active route (lowest position number)
                    const activeRoute = groupRoutes.reduce((prev, current) =>
                        (prev.pos < current.pos) ? prev : current
                    );

                    const routeButtons = groupRoutes.map(route => {
                        const isActive = route.id === activeRoute.id;
                        const dest = route.def_dest || route.default_destination;
                        const destValue = route.def_dest_value ||
                                         route.default_destination_value ||
                                         route.default_desination_value;
                        const destName = getCurrentDestinationName(dest, destValue);

                        return `
                            <button class="btn ${isActive ? 'btn-primary' : 'btn-secondary'} btn-sm"
                                    onclick="switchToRoute(${route.id}, '${pattern}')"
                                    ${isActive ? 'disabled' : ''}>
                                ${route.name} → ${destName}
                            </button>
                        `;
                    }).join('');

                    groupElement.innerHTML = `
                        <div style="margin-bottom: 1rem;">
                            <h4>Routes for: ${pattern}</h4>
                            <p style="font-size: 0.875rem; opacity: 0.7;">
                                Active: <strong>${activeRoute.name}</strong> (Position: ${activeRoute.pos})
                            </p>
                        </div>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            ${routeButtons}
                        </div>
                    `;
                    container.appendChild(groupElement);
                });

                if (Object.keys(routeGroups).length === 0) {
                    // Try an alternative grouping method based on route name similarity
                    const alternativeGroups = groupRoutesByNamePattern(routes);
                    if (Object.keys(alternativeGroups).length > 0) {
                        console.log('Using alternative name-based grouping:', alternativeGroups);
                        renderAlternativeRouteSwitching(container, alternativeGroups);
                    } else {
                        container.innerHTML = '<p>No route groups found for switching. You need multiple routes with the same DID pattern to use route switching.</p>';
                    }
                }
            }

            function groupRoutesByPattern(routes) {
                const groups = {};

                routes.forEach(route => {
                    console.log('Processing route for grouping:', {
                        name: route.name,
                        did_pattern_list: route.did_pattern_list,
                        did_patterns: route.did_patterns,
                        did_list: route.did_list,
                        patterns: route.patterns
                    });

                    // Try multiple possible field names for DID patterns
                    let didPatterns = route.did_pattern_list ||
                                     route.did_patterns ||
                                     route.did_list ||
                                     route.patterns;

                    let key;
                    if (didPatterns && Array.isArray(didPatterns) && didPatterns.length > 0) {
                        // Use the first DID pattern as the grouping key
                        key = didPatterns[0];
                    } else if (didPatterns && typeof didPatterns === 'string') {
                        // Sometimes it might be a string instead of array
                        key = didPatterns;
                    } else {
                        // Fallback: group by route name pattern (if they follow a naming convention)
                        // or create a generic key for routes without DID patterns
                        key = `no-did-pattern-${route.name}`;
                    }

                    console.log('Grouping route', route.name, 'under key:', key);

                    if (!groups[key]) {
                        groups[key] = [];
                    }
                    groups[key].push(route);
                });

                console.log('All groups before filtering:', groups);

                // Only return groups with multiple routes
                const multiRouteGroups = {};
                Object.keys(groups).forEach(key => {
                    if (groups[key].length > 1) {
                        multiRouteGroups[key] = groups[key];
                        console.log('Found multi-route group:', key, 'with', groups[key].length, 'routes');
                    }
                });

                console.log('Final multi-route groups:', multiRouteGroups);
                return multiRouteGroups;
            }

            function groupRoutesByNamePattern(routes) {
                const groups = {};

                routes.forEach(route => {
                    // Look for routes with similar names (e.g., "In_0202_VM" and "In_0202")
                    // Extract base pattern from route name
                    let basePattern = route.name;

                    // Remove common suffixes to find base pattern
                    const suffixes = ['_VM', '_IVR', '_EXT', '_QUEUE', '_END'];
                    suffixes.forEach(suffix => {
                        if (basePattern.endsWith(suffix)) {
                            basePattern = basePattern.replace(suffix, '');
                        }
                    });

                    // Also try extracting number patterns (like 0202 from In_0202_VM)
                    const numberMatch = route.name.match(/(\d{3,})/);
                    if (numberMatch) {
                        basePattern = numberMatch[1]; // Use the number as the base pattern
                    }

                    console.log('Name-based grouping:', route.name, '→', basePattern);

                    if (!groups[basePattern]) {
                        groups[basePattern] = [];
                    }
                    groups[basePattern].push(route);
                });

                // Only return groups with multiple routes
                const multiRouteGroups = {};
                Object.keys(groups).forEach(key => {
                    if (groups[key].length > 1) {
                        multiRouteGroups[key] = groups[key];
                    }
                });

                return multiRouteGroups;
            }

            function renderAlternativeRouteSwitching(container, routeGroups) {
                Object.keys(routeGroups).forEach(pattern => {
                    const groupRoutes = routeGroups[pattern];

                    const groupElement = document.createElement('div');
                    groupElement.style.backgroundColor = 'var(--color-base-200)';
                    groupElement.style.padding = '1rem';
                    groupElement.style.borderRadius = 'var(--radius)';
                    groupElement.style.marginBottom = '1rem';

                    // Find the currently active route (lowest position number)
                    const activeRoute = groupRoutes.reduce((prev, current) =>
                        (prev.pos < current.pos) ? prev : current
                    );

                    const routeButtons = groupRoutes.map(route => {
                        const isActive = route.id === activeRoute.id;
                        const dest = route.def_dest || route.default_destination;
                        const destValue = route.def_dest_value ||
                                         route.default_destination_value ||
                                         route.default_desination_value;
                        const destName = getCurrentDestinationName(dest, destValue);

                        return `
                            <button class="btn ${isActive ? 'btn-primary' : 'btn-secondary'} btn-sm"
                                    onclick="switchToRoute(${route.id}, '${pattern}')"
                                    ${isActive ? 'disabled' : ''}>
                                ${route.name} → ${destName}
                            </button>
                        `;
                    }).join('');

                    groupElement.innerHTML = `
                        <div style="margin-bottom: 1rem;">
                            <h4>Route Group: ${pattern}</h4>
                            <p style="font-size: 0.875rem; opacity: 0.7;">
                                Active: <strong>${activeRoute.name}</strong> (Position: ${activeRoute.pos})
                            </p>
                        </div>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            ${routeButtons}
                        </div>
                    `;
                    container.appendChild(groupElement);
                });
            }

            window.switchToRoute = async function(targetRouteId, pattern) {
                try {
                    // First, get all routes to understand current positions
                    const routesResult = await apiRequest('inbound_route/list?page_size=100&sort_by=pos&order_by=asc');
                    if (!routesResult || routesResult.errcode !== 0) {
                        throw new Error('Failed to fetch routes for switching');
                    }

                    const routes = routesResult.data;
                    const routeGroups = groupRoutesByPattern(routes);
                    const groupRoutes = routeGroups[pattern];

                    if (!groupRoutes) {
                        throw new Error('Route group not found');
                    }

                    // Find the target route
                    const targetRoute = groupRoutes.find(r => r.id === targetRouteId);
                    if (!targetRoute) {
                        throw new Error('Target route not found');
                    }

                    // Find the currently active route (lowest position in the group)
                    const currentActiveRoute = groupRoutes.reduce((prev, current) =>
                        (prev.pos < current.pos) ? prev : current
                    );

                    if (targetRoute.id === currentActiveRoute.id) {
                        alert('This route is already active');
                        return;
                    }

                    // Strategy: Swap positions between current active and target route
                    const currentActivePos = currentActiveRoute.pos;
                    const targetPos = targetRoute.pos;

                    // Update the current active route to have a higher position
                    const updateCurrentResult = await apiRequest('inbound_route/update', 'POST', {
                        id: currentActiveRoute.id,
                        pos: targetPos
                    });

                    if (!updateCurrentResult || updateCurrentResult.errcode !== 0) {
                        throw new Error(`Failed to update current active route position: ${updateCurrentResult ? updateCurrentResult.errmsg : 'Unknown error'}`);
                    }

                    // Update the target route to have the lowest position (making it active)
                    const updateTargetResult = await apiRequest('inbound_route/update', 'POST', {
                        id: targetRoute.id,
                        pos: currentActivePos
                    });

                    if (!updateTargetResult || updateTargetResult.errcode !== 0) {
                        throw new Error(`Failed to update target route position: ${updateTargetResult ? updateTargetResult.errmsg : 'Unknown error'}`);
                    }

                    alert(`Successfully switched to route: ${targetRoute.name}`);

                    // Refresh all route displays
                    fetchAndRenderRouteSwitching();
                    fetchAndRenderInboundRoutes();
                    fetchAndRenderQuickOverride();

                } catch (error) {
                    console.error('Route switching error:', error);
                    alert(`Failed to switch route: ${error.message}`);
                }
            };

            // 4. Recent Calls
            let currentCallsPage = 1;
            async function fetchAndRenderRecentCalls(page = 1) {
                currentCallsPage = page;
                setLoader('recent-calls', true);
                const endpoint = `cdr/list?page_size=3&sort_by=time&order_by=desc&page=${page}`;
                const result = await apiRequest(endpoint);

                if (result && result.errcode === 0) {
                    renderRecentCalls(result.data, page);
                } else {
                    renderRecentCalls([], page);
                }
                setLoader('recent-calls', false);
                updatePaginationButtons(result);
            }

            function renderRecentCalls(calls, page) {
                const container = document.getElementById('recent-calls-content');
                container.innerHTML = '';
                if (calls.length === 0) {
                    container.innerHTML = '<p>No recent calls found.</p>';
                    return;
                }
                calls.forEach(call => {
                    const callElement = document.createElement('div');
                    callElement.style.backgroundColor = 'var(--color-base-200)';
                    callElement.style.padding = '0.75rem';
                    callElement.style.borderRadius = 'var(--radius)';
                    callElement.style.display = 'flex';
                    callElement.style.justifyContent = 'space-between';
                    callElement.style.alignItems = 'center';
                    callElement.innerHTML = `
                        <div>
                            <p>${call.call_from} -> ${call.call_to}</p>
                            <p style="font-size: 0.875rem; opacity: 0.7;">${call.time} - ${call.disposition} (${formatDuration(call.talk_duration)})</p>
                        </div>
                        <div>
                            <span class="badge ${getCallTypeBadge(call.call_type)}">${call.call_type}</span>
                        </div>
                    `;
                    container.appendChild(callElement);
                });
                document.getElementById('page-info').textContent = `Page ${page}`;
            }
            
            function updatePaginationButtons(result) {
                const prevBtn = document.getElementById('prev-calls');
                const nextBtn = document.getElementById('next-calls');
                const pageInfo = document.getElementById('page-info');
                prevBtn.disabled = currentCallsPage <= 1;
                nextBtn.disabled = !result || result.data.length < 3;  // Assume no more if < page_size
                // Note: For full pagination, we'd need total count from API; this is simple heuristic
            }

            document.getElementById('prev-calls').addEventListener('click', () => {
                if (currentCallsPage > 1) fetchAndRenderRecentCalls(currentCallsPage - 1);
            });
            document.getElementById('next-calls').addEventListener('click', () => {
                fetchAndRenderRecentCalls(currentCallsPage + 1);
            });

            // --- UTILITY FUNCTIONS ---
            function formatTrunkStatus(status) {
                const statusMap = { 0: 'Idle', 1: 'Busy', 2: 'Ringing', 3: 'Dialing', 4: 'Unavailable', 5: 'Registering', 6: 'Registered', 7: 'Unregistered', 8: 'Failed', 9: 'Authenticating', 10: 'Connecting' };
                return statusMap[status] || 'Unknown';
            }

            function getTrunkStatusBadge(status) {
                 switch (status) {
                    case 6: return 'badge-success';
                    case 0: return 'badge-info';
                    case 1: return 'badge-warning';
                    case 8: return 'badge-error';
                    default: return 'badge-ghost';
                }
            }

            function setLoader(type, isLoading) {
                const loader = document.getElementById(`${type}-loader`);
                const content = document.getElementById(`${type}-content`);
                if (!loader || !content) return; 
                if (isLoading) {
                    loader.classList.remove('hidden');
                    content.classList.add('hidden');
                } else {
                    loader.classList.add('hidden');
                    content.classList.remove('hidden');
                }
            }

            function formatDuration(seconds) {
                if (seconds === null || seconds === undefined) return '0s';
                if (seconds < 60) return `${seconds}s`;
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                return `${minutes}m ${remainingSeconds}s`;
            }

            function getCallTypeBadge(type) {
                if (!type) return 'badge-ghost';
                switch (type.toLowerCase()) {
                    case 'inbound': return 'badge-success';
                    case 'outbound': return 'badge-info';
                    case 'internal': return 'badge-warning';
                    default: return 'badge-ghost';
                }
            }

            // --- PWA Service Worker ---
            // function registerServiceWorker() {
            //     if ('serviceWorker' in navigator) {
            //         const swContent = `
            //             const CACHE_NAME = 'yeastar-dashboard-cache-v2';
            //             const urlsToCache = ['./index.html', './style.css'];
            //             self.addEventListener('install', event => { event.waitUntil( caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache)) ); });
            //             self.addEventListener('activate', event => { const cacheWhitelist = [CACHE_NAME]; event.waitUntil( caches.keys().then(cacheNames => Promise.all( cacheNames.map(cacheName => { if (cacheWhitelist.indexOf(cacheName) === -1) { return caches.delete(cacheName); } }) )) ); });
            //             self.addEventListener('fetch', event => { if (event.request.url.startsWith('http')) { event.respondWith( caches.open(CACHE_NAME).then(cache => cache.match(event.request).then(response => { const fetchPromise = fetch(event.request).then(networkResponse => { if (!event.request.url.includes('/openapi/v1.0/')) { cache.put(event.request, networkResponse.clone()); } return networkResponse; }); return response || fetchPromise; })) ); } });
            //         `;
            //         const blob = new Blob([swContent], {type: 'application/javascript'});
            //         const swUrl = URL.createObjectURL(blob);
            //         navigator.serviceWorker.register(swUrl).then(reg => console.log('SW reg success', reg)).catch(err => console.log('SW reg failed', err));
            //     }
            // }

            // function setupManifest() {
            //      const manifest = {
            //         "name": "Yeastar PBX Dashboard", "short_name": "PBX Dash", "start_url": ".", "display": "standalone", "background_color": "#ffffff", "theme_color": "#ffffff",
            //         "icons": [ { "src": "https://placehold.co/192x192/3498db/FFFFFF?text=PBX", "sizes": "192x192", "type": "image/png" }, { "src": "https://placehold.co/512x512/3498db/FFFFFF?text=PBX", "sizes": "512x512", "type": "image/png" } ]
            //     };
            //     const blob = new Blob([JSON.stringify(manifest)], {type: 'application/json'});
            //     const manifestURL = URL.createObjectURL(blob);
            //     document.querySelector('link[rel="manifest"]').setAttribute('href', manifestURL);
            // }

            // --- INITIALIZATION ---
            // setupManifest();
            // registerServiceWorker();

            // --- EVENT LISTENERS ---
            connectBtn.addEventListener('click', async () => {
                proxyUrl = proxyUrlInput.value.trim();
                pbxHost = pbxHostInput.value.trim();
                const clientId = clientIdInput.value.trim();
                const clientSecret = clientSecretInput.value.trim();

                if (!proxyUrl || !pbxHost || !clientId || !clientSecret) {
                    alert('Please fill in all API configuration fields.');
                    return;
                }
                
                sessionStorage.removeItem('yeastar_accessToken');
                accessToken = null;

                const initialAccessToken = await getAccessToken(pbxHost, clientId, clientSecret);
                if (initialAccessToken) {
                    accessToken = initialAccessToken;
                    apiConfigSection.classList.add('hidden');
                    dashboardContent.classList.remove('hidden');
                    
                    const extensionIds = await fetchAllExtensions();
                    
                    if(extensionIds) {
                        Promise.all([
                            fetchAndRenderStats(extensionIds),
                            fetchAndRenderQuickOverride(),
                            fetchAndRenderRouteSwitching(),
                            fetchAndRenderInboundRoutes(),
                            fetchAndRenderRecentCalls(1)
                        ]);
                    }

                    if (extensionIds.length > 0 && accessToken) {
                        // Polling for live sections (every 10 seconds)
                        setInterval(() => {
                            // fetchAndRenderRecentCalls(1); // Polling for recent calls
                        }, 10000);  // 10 seconds
                    }
                }
            });
            
            saveConfigBtn.addEventListener('click', () => {
                const config = {
                    proxyUrl: proxyUrlInput.value.trim(),
                    host: pbxHostInput.value.trim(),
                    clientId: clientIdInput.value.trim(),
                    clientSecret: clientSecretInput.value.trim()
                };
                if(config.proxyUrl && config.host && config.clientId && config.clientSecret) {
                    localStorage.setItem('yeastarConfig', JSON.stringify(config));
                    alert('Configuration saved to your browser\'s local storage.');
                } else {
                    alert('Please fill all fields before saving.');
                }
            });

            document.getElementById('refresh-recent').addEventListener('click', () => fetchAndRenderRecentCalls(currentCallsPage));
        });
    </script>
</body>
</html>
