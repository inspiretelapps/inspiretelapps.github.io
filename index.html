<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yeastar P-Series Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    
    <!-- PWA Manifest and Theme Color -->
    <!-- <link rel="manifest" href="manifest.json"> -->
    <meta name="theme-color" content="#ffffff">
    <link rel="apple-touch-icon" href="https://placehold.co/192x192/3498db/FFFFFF?text=PBX">
</head>
<body>

    <div class="container">
        <header>
            <h1>Yeastar Dashboard</h1>
            <label class="flex cursor-pointer gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><path d="M12 1v2M12 21v2M4.2 4.2l1.4 1.4M18.4 18.4l1.4 1.4M1 12h2M21 12h2M4.2 19.8l1.4-1.4M18.4 5.6l1.4-1.4"/></svg>
                <input type="checkbox" id="theme-toggle" class="toggle"/>
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
            </label>
        </header>

        <!-- API Configuration -->
        <div id="api-config-section" class="card">
            <h2>API Configuration</h2>
            <div class="form-group">
                <label for="proxy-url">Proxy URL</label>
                <input type="text" id="proxy-url" class="input" placeholder="https://your-proxy.herokuapp.com/">
            </div>
            <div class="form-group">
                <label for="pbx-host">PBX Host URL</label>
                <input type="text" id="pbx-host" class="input" placeholder="pbx.yeastarcloud.com">
            </div>
            <div class="form-group">
                <label for="client-id">Client ID</label>
                <input type="text" id="client-id" class="input" placeholder="Your Client ID">
            </div>
            <div class="form-group">
                <label for="client-secret">Client Secret</label>
                <input type="password" id="client-secret" class="input" placeholder="Your Client Secret">
            </div>
            <button id="connect-btn" class="btn btn-primary">Connect & Fetch Data</button>
            <button id="save-config-btn" class="btn btn-secondary">Save Config</button>
            <p style="font-size: 0.75rem; opacity: 0.7; margin-top: 1rem;">Note: Ensure the IP address of your proxy is whitelisted in your Yeastar PBX's API settings.</p>
        </div>

        <div id="dashboard-content" class="hidden">
            <!-- Today's Stats -->
            <div class="card">
                <h2>Today's Stats</h2>
                <div id="stats-loader">Loading...</div>
                <div id="stats-content" class="hidden">
                    <div id="overall-stats" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; text-align: center; margin-bottom: 1.5rem;">
                        <!-- Overall stats will be injected here -->
                    </div>
                    <div id="extension-stats">
                        <h3>Per Extension</h3>
                        <div style="overflow-x: auto;">
                            <table id="extension-stats-body">
                                <!-- Extension stats rows will be injected here -->
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Recent Calls -->
            <div class="card">
                <h2>Recent Calls</h2>
                <button id="refresh-recent" class="btn btn-secondary" style="margin-bottom: 1rem;">Refresh</button>
                <div id="recent-calls-loader">Loading...</div>
                <div id="recent-calls-content" class="hidden">
                    <!-- Recent calls will be injected here -->
                </div>
                <div id="recent-calls-pagination" class="hidden" style="display: flex; justify-content: center; gap: 1rem; margin-top: 1rem;">
                    <button id="prev-calls" class="btn" disabled>Previous</button>
                    <span id="page-info">Page 1</span>
                    <button id="next-calls" class="btn">Next</button>
                </div>
            </div>

            <!-- Quick Route Override -->
            <div class="card">
                <h2>Quick Route Override</h2>
                <p style="font-size: 0.875rem; opacity: 0.7; margin-bottom: 1rem;">Quickly change where calls go with preset options</p>
                <div id="quick-override-loader">Loading...</div>
                <div id="quick-override-content" class="hidden">
                    <!-- Quick override buttons will be injected here -->
                </div>
            </div>

            <!-- Route Switching System -->
            <div class="card">
                <h2>Route Switching System</h2>
                <p style="font-size: 0.875rem; opacity: 0.7; margin-bottom: 1rem;">Switch between predefined route configurations by changing route priorities</p>
                <div id="route-switching-loader">Loading...</div>
                <div id="route-switching-content" class="hidden">
                    <!-- Route switching controls will be injected here -->
                </div>
            </div>

        </div>

        <!-- Edit Route Modal -->
        <dialog id="edit-route-modal" class="modal">
            <div class="modal-box">
                <h3 id="edit-route-modal-title">Edit Inbound Route</h3>
                <form id="edit-route-form">
                    <input type="hidden" id="edit-route-id">
                    <div class="form-group">
                        <label for="simple-dest-select">Destination</label>
                        <select id="simple-dest-select" class="input"></select>
                    </div>
                    <div class="modal-action">
                        <button type="submit" class="btn btn-primary">Save Changes</button>
                        <button type="button" class="btn" onclick="document.getElementById('edit-route-modal').close()">Cancel</button>
                    </div>
                </form>
            </div>
        </dialog>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- THEME CONTROLLER ---
            const themeToggle = document.getElementById('theme-toggle');
            const htmlElement = document.documentElement;

            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (prefersDark) {
                htmlElement.classList.add('dark-mode');
                themeToggle.checked = true;
            }

            themeToggle.addEventListener('change', () => {
                htmlElement.classList.toggle('dark-mode');
            });

            // DOM Elements
            const proxyUrlInput = document.getElementById('proxy-url');
            const pbxHostInput = document.getElementById('pbx-host');
            const clientIdInput = document.getElementById('client-id');
            const clientSecretInput = document.getElementById('client-secret');
            const connectBtn = document.getElementById('connect-btn');
            const saveConfigBtn = document.getElementById('save-config-btn');
            const apiConfigSection = document.getElementById('api-config-section');
            const dashboardContent = document.getElementById('dashboard-content');
            const queueSelect = document.getElementById('queue-select');

            // Load saved config
            const savedConfig = JSON.parse(localStorage.getItem('yeastarConfig'));
            if (savedConfig) {
                proxyUrlInput.value = savedConfig.proxyUrl;
                pbxHostInput.value = savedConfig.host;
                clientIdInput.value = savedConfig.clientId;
                clientSecretInput.value = savedConfig.clientSecret;
            }

            // Global state
            let accessToken = sessionStorage.getItem('yeastar_accessToken');
            let pbxHost = '';
            let proxyUrl = '';
            let extensionMap = new Map();
            let extensionList = [];
            let ivrList = [];
            let queueList = [];
            
            // --- API HELPER ---
            async function apiRequest(endpoint, method = 'GET', body = null, isRetry = false) {
                if (!accessToken) {
                    if (isRetry) {
                        alert('Authentication failed. Please check your credentials and connect again.');
                        return null;
                    }
                    console.log("Access token missing, attempting to get a new one...");
                    const newAccessToken = await getAccessToken(pbxHostInput.value, clientIdInput.value, clientSecretInput.value);
                    if (newAccessToken) {
                        accessToken = newAccessToken;
                        return apiRequest(endpoint, method, body, true);
                    } else {
                        return null;
                    }
                }

                // Build the target URL for the proxy
                const targetUrl = `${pbxHost}/openapi/v1.0/${endpoint.split('?')[0]}`;
                const params = new URLSearchParams(endpoint.split('?')[1] || '');
                params.append('access_token', accessToken);
                
                // Use the new proxy format: proxyUrl + /api/proxy/ + targetUrl
                const finalUrl = `${proxyUrl}/api/proxy/${targetUrl}?${params.toString()}`;

                const options = {
                    method,
                    headers: {
                        'Content-Type': 'application/json',
                        'User-Agent': 'YeastarDashboardWebApp',
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                };
                if (body) {
                    options.body = JSON.stringify(body);
                }

                try {
                    const response = await fetch(finalUrl, options);
                    const responseText = await response.text();
                    if (endpoint.includes('update')) {
                        console.log('Raw update response for ' + endpoint + ':', responseText.substring(0, 500));
                    }
                    let responseData;
                    try {
                        responseData = JSON.parse(responseText);
                    } catch (e) {
                        console.error('Parse error for ' + endpoint + ':', e, 'Raw:', responseText.substring(0, 200));
                        throw new Error('PBX returned non-JSON for ' + endpoint + '. Raw: ' + responseText.substring(0, 200));
                    }
                    if (!responseData) {
                        throw new Error('PBX returned empty data for ' + endpoint);
                    }
                    
                    if (responseData.errcode === 10004 && !isRetry) { // Token expired
                        console.log("Token expired, refreshing...");
                        accessToken = null;
                        sessionStorage.removeItem('yeastar_accessToken');
                        return apiRequest(endpoint, method, body, true);
                    }

                    if (!response.ok || (responseData.errcode && responseData.errcode !== 0)) {
                        throw new Error(`API Error ${responseData.errcode}: ${responseData.errmsg}`);
                    }
                    return responseData;
                } catch (error) {
                    console.error(`Error in apiRequest for ${endpoint}:`, error);
                     if (error instanceof SyntaxError) {
                        alert('Failed to parse API response. This is likely a CORS proxy issue. Please click the "Activate API Proxy" link, request temporary access on that page, and then try connecting again.');
                    } else {
                        alert(`An error occurred while fetching data from ${endpoint}. ${error.message}`);
                    }
                    return null;
                }
            }
            
            // --- AUTHENTICATION ---
            async function getAccessToken(host, clientId, clientSecret) {
                const targetUrl = `${host}/openapi/v1.0/get_token`;
                const url = `${proxyUrl}/api/proxy/${targetUrl}`;
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'User-Agent': 'YeastarDashboardWebApp',
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        body: JSON.stringify({
                            username: clientId,
                            password: clientSecret
                        })
                    });
                    
                    const responseText = await response.text();
                    let data;
                    try {
                        data = JSON.parse(responseText);
                    } catch (e) {
                        console.error('Auth parse error:', responseText.substring(0, 200));
                        throw new Error('Proxy/PBX returned invalid response (not JSON). Raw: ' + responseText.substring(0, 200) + '. Test proxy separately.');
                    }

                    if (data.errcode === 0) {
                        sessionStorage.setItem('yeastar_accessToken', data.access_token);
                        return data.access_token;
                    } else {
                        throw new Error(`Auth failed: Error ${data.errcode}: ${data.errmsg || 'Unknown'}. Check creds/host.`);
                    }
                } catch (error) {
                    console.error('Error getting access token:', error);
                    alert(`Failed to get access token: ${error.message}. Please check Proxy URL (${proxyUrl}), credentials, and PBX Host URL (${pbxHost}). Use test-proxy.html for details.`);
                    return null;
                }
            }


            // --- DATA FETCHING AND RENDERING ---

            // 0. Trunk Status
            // async function fetchAndRenderTrunkStatus() {
            //     setLoader('trunk-status', true);
            //     const result = await apiRequest('trunk/list');
            //     if (result && result.errcode === 0) {
            //         renderTrunkStatus(result.data);
            //     } else {
            //         renderTrunkStatus([]);
            //     }
            //     setLoader('trunk-status', false);
            // }

            // function renderTrunkStatus(trunks) {
            //     const container = document.getElementById('trunk-status-content');
            //     container.innerHTML = '';
            //     if (!trunks || trunks.length === 0) {
            //         container.innerHTML = '<p>No trunks found.</p>';
            //         return;
            //     }

            //     const table = document.createElement('table');
            //     table.innerHTML = `
            //         <thead>
            //             <tr>
            //                 <th>Name</th>
            //                 <th>Type</th>
            //                 <th class="text-center">Status</th>
            //             </tr>
            //         </thead>
            //         <tbody>
            //         </tbody>
            //     `;
            //     const tbody = table.querySelector('tbody');
            //     trunks.forEach(trunk => {
            //         const row = `
            //             <tr>
            //                 <td>${trunk.name}</td>
            //                 <td>${trunk.type}</td>
            //                 <td class="text-center"><span class="badge ${getTrunkStatusBadge(trunk.status)}">${formatTrunkStatus(trunk.status)}</span></td>
            //             </tr>
            //         `;
            //         tbody.innerHTML += row;
            //     });
            //     container.appendChild(table);
            // }


            async function fetchAllExtensions() {
                const result = await apiRequest('extension/list?page_size=1000');
                if (result && result.data) {
                    extensionMap.clear();
                    result.data.forEach(ext => {
                        extensionMap.set(ext.number, ext.id);
                    });
                    return result.data.map(ext => ext.id);
                }
                return [];
            }

            // 1. Today's Stats
            async function fetchAndRenderStats(extensionIds) {
                setLoader('stats', true);
                
                if (extensionIds.length === 0) {
                    console.log("No extensions found to fetch stats for.");
                    renderStats([]);
                    setLoader('stats', false);
                    return;
                }

                const today = new Date();
                const year = today.getFullYear();
                const month = String(today.getMonth() + 1).padStart(2, '0');
                const day = String(today.getDate()).padStart(2, '0');

                const startTime = `${year}/${month}/${day} 00:00:00`;
                const endTime = `${year}/${month}/${day} 23:59:59`;

                const endpoint = `call_report/list?type=extcallstatistics&start_time=${encodeURIComponent(startTime)}&end_time=${encodeURIComponent(endTime)}&ext_id_list=${extensionIds.join(',')}`;
                
                console.log('🔍 FETCHING STATS:', {
                    endpoint,
                    extensionIds,
                    startTime,
                    endTime
                });
                
                const result = await apiRequest(endpoint);

                console.log('📊 RAW STATS RESPONSE:', JSON.stringify(result, null, 2));
                console.log('📊 RAW STATS RESPONSE (Enhanced):', {
                    endpoint: endpoint,
                    fullResponse: JSON.stringify(result, null, 2),
                    dataStructure: result ? Object.keys(result) : 'No result',
                    statsList: result ? (result.ext_call_statistics_list || result.data || []) : []
                });

                if (result && result.errcode === 0) {
                    // Handle both possible response structures
                    const statsList = result.ext_call_statistics_list || result.data || [];
                    console.log('📋 Stats list found:', statsList);
                    renderStats(statsList);
                } else {
                    console.error("❌ Failed to fetch stats or no stats available:", result);
                    renderStats([]);
                }
                setLoader('stats', false);
            }

            function renderStats(stats) {
                let totalAnswered = 0;
                let totalDuration = 0;
                let totalMissed = 0;
                
                const extensionStatsBody = document.getElementById('extension-stats-body');
                extensionStatsBody.innerHTML = '';

                if (!stats || stats.length === 0) {
                    const row = `
                        <tr>
                            <td colspan="3" class="text-center">No call statistics for today.</td>
                        </tr>
                    `;
                    extensionStatsBody.innerHTML = row;
                } else {
                    stats.forEach(ext => {
                        // Log ALL fields to see what the API actually returns
                        console.log('📞 COMPLETE EXTENSION DATA:', {
                            name: ext.ext_name,
                            number: ext.ext_num,
                            ALL_FIELDS: Object.keys(ext),
                            FULL_OBJECT: ext
                        });

                        // Try multiple possible field name variations from Yeastar API
                        const inboundAnswered = ext.inbound_answered_calls || 
                                               ext.answered_inbound_calls || 
                                               ext.inbound_calls ||
                                               ext.incoming_calls ||
                                               ext.answered_incoming_calls ||
                                               ext.inbound_talking ||
                                               ext.in_calls ||
                                               0;
                        const outboundAnswered = ext.outbound_answered_calls || 
                                                ext.answered_outbound_calls || 
                                                ext.outbound_calls ||
                                                ext.outgoing_calls ||
                                                ext.answered_outgoing_calls ||
                                                ext.outbound_talking ||
                                                ext.out_calls ||
                                                0;

                        console.log(`📊 ${ext.ext_name} (${ext.ext_num}): Inbound=${inboundAnswered}, Outbound=${outboundAnswered}`);

                        const row = `
                            <tr>
                                <td>${ext.ext_name} (${ext.ext_num})</td>
                                <td class="text-center"><strong>${inboundAnswered}/${outboundAnswered}</strong></td>
                                <td class="text-center">${formatDuration(ext.total_talking_time || ext.talk_duration || 0)}</td>
                            </tr>
                        `;
                        extensionStatsBody.innerHTML += row;

                        totalAnswered += (ext.answered_calls || 0);
                        totalDuration += (ext.total_talking_time || ext.talk_duration || 0);
                        totalMissed += (ext.missed_calls || ext.unanswered_calls || 0);
                    });
                }

                const overallStatsContainer = document.getElementById('overall-stats');
                overallStatsContainer.innerHTML = `
                    <div style="padding: 1rem; background: var(--color-base-200); border-radius: 0.5rem;">
                        <div style="font-size: 0.875rem; opacity: 0.8; margin-bottom: 0.25rem;">Total Answered</div>
                        <div style="font-size: 1.5rem; font-weight: 700;">${totalAnswered}</div>
                    </div>
                    <div style="padding: 1rem; background: var(--color-base-200); border-radius: 0.5rem;">
                        <div style="font-size: 0.875rem; opacity: 0.8; margin-bottom: 0.25rem;">Total Missed</div>
                        <div style="font-size: 1.5rem; font-weight: 700; color: var(--color-error);">${totalMissed}</div>
                    </div>
                    <div style="padding: 1rem; background: var(--color-base-200); border-radius: 0.5rem;">
                        <div style="font-size: 0.875rem; opacity: 0.8; margin-bottom: 0.25rem;">Total Duration</div>
                        <div style="font-size: 1.5rem; font-weight: 700;">${formatDuration(totalDuration)}</div>
                    </div>
                `;
            }


            // Quick Override functionality
            async function fetchAndRenderQuickOverride() {
                setLoader('quick-override', true);

                // Fetch all necessary data
                const [routeResult, extResult, ivrResult, queueResult] = await Promise.all([
                    apiRequest('inbound_route/list?page_size=100'),
                    apiRequest('extension/list?page_size=100'),
                    apiRequest('ivr/list?page_size=100'),
                    apiRequest('queue/list?page_size=100')
                ]);

                // Store data globally
                if (extResult && extResult.errcode === 0) {
                    extensionList = extResult.data || [];
                }
                if (ivrResult && ivrResult.errcode === 0) {
                    ivrList = ivrResult.data || [];
                }
                if (queueResult && queueResult.errcode === 0) {
                    queueList = queueResult.queue_list || queueResult.data || [];
                }

                if (routeResult && routeResult.errcode === 0) {
                    renderQuickOverride(routeResult.data);
                } else {
                    renderQuickOverride([]);
                }
                setLoader('quick-override', false);
            }

            function renderQuickOverride(routes) {
                const container = document.getElementById('quick-override-content');
                container.innerHTML = '';

                if (!routes || routes.length === 0) {
                    container.innerHTML = '<p>No inbound routes found.</p>';
                    return;
                }

                routes.forEach(route => {
                    console.log('Route data:', route); // Debug route data
                    const routeCard = document.createElement('div');
                    routeCard.style.backgroundColor = 'var(--color-base-200)';
                    routeCard.style.padding = '1rem';
                    routeCard.style.borderRadius = 'var(--radius)';
                    routeCard.style.marginBottom = '1rem';

                    // Improved destination handling with comprehensive field checking
                    let dest, destValue;
                    if (route.time_condition === 'disabled' || !route.time_condition) {
                        // Simple routing - check all possible field name variations
                        dest = route.def_dest || route.default_destination || route.destination;
                        destValue = route.def_dest_value ||
                                   route.default_destination_value ||
                                   route.default_desination_value || // API typo
                                   route.destination_value ||
                                   route.def_destination_value;
                    } else {
                        // Time-based routing - show primary destination with fallbacks
                        dest = route.business_hours_destination || route.bh_destination;
                        destValue = route.business_hours_destination_value ||
                                   route.bh_destination_value ||
                                   route.business_hours_dest_value;
                    }

                    const currentDest = getCurrentDestinationName(dest, destValue);
                    console.log('Route', route.name, '- time_condition:', route.time_condition, 'dest:', dest, 'destValue:', destValue, 'result:', currentDest);

                    // Create 2 customizable buttons per route
                    const routeId = route.id;

                    routeCard.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                            <div>
                                <h4>${route.name}</h4>
                                <p style="font-size: 0.875rem; opacity: 0.7;">Currently: ${currentDest}</p>
                            </div>
                            <button class="btn btn-secondary btn-sm" onclick="configureQuickButtons(${routeId})">⚙️ Configure</button>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                            <button class="btn btn-primary btn-sm quick-btn-1" data-route-id="${routeId}" onclick="executeQuickButton(${routeId}, 1)">
                                <span class="btn-label">Button 1</span>
                            </button>
                            <button class="btn btn-secondary btn-sm quick-btn-2" data-route-id="${routeId}" onclick="executeQuickButton(${routeId}, 2)">
                                <span class="btn-label">Button 2</span>
                            </button>
                        </div>
                    `;
                    container.appendChild(routeCard);

                    // Load saved button configurations or set defaults
                    loadQuickButtonConfig(routeId);
                });
            }

            function getCurrentDestinationName(dest, destValue) {
                console.log('getCurrentDestinationName called with:', { dest, destValue, extensionList: extensionList.length, ivrList: ivrList.length });

                if (!dest) return 'No destination set';

                switch(dest) {
                    case 'extension': {
                        const ext = extensionList.find(e => e.id == destValue);
                        console.log('Extension lookup:', { destValue, found: ext });
                        return ext ? `Extension ${ext.number} (${ext.display_name || ext.username || 'Unnamed'})` : `Extension ${destValue}`;
                    }
                    case 'ivr': {
                        const ivr = ivrList.find(i => i.id == destValue);
                        console.log('IVR lookup:', { destValue, found: ivr });
                        return ivr ? `IVR: ${ivr.name}` : `IVR ${destValue}`;
                    }
                    case 'queue': {
                        const queue = queueList.find(q => q.id == destValue);
                        return queue ? `Queue: ${queue.name}` : `Queue ${destValue}`;
                    }
                    case 'ext_vm': {
                        const ext = extensionList.find(e => e.id == destValue);
                        return ext ? `Voicemail ${ext.number}` : `Voicemail ${destValue}`;
                    }
                    case 'end_call': return 'End Call';
                    default: return `${dest} ${destValue}`;
                }
            }

            function getMainExtension() {
                // Return the first extension ID from the list
                return extensionList.length > 0 ? extensionList[0].id : '1';
            }

            function getMainIVR() {
                // Return the first IVR ID from the list
                return ivrList.length > 0 ? ivrList[0].id : '1';
            }

            // Quick Button Configuration System
            function loadQuickButtonConfig(routeId) {
                const config = JSON.parse(localStorage.getItem(`quickButtons_${routeId}`)) || getDefaultButtonConfig();

                const btn1 = document.querySelector(`.quick-btn-1[data-route-id="${routeId}"] .btn-label`);
                const btn2 = document.querySelector(`.quick-btn-2[data-route-id="${routeId}"] .btn-label`);

                if (btn1) btn1.textContent = config.button1.label;
                if (btn2) btn2.textContent = config.button2.label;
            }

            function getDefaultButtonConfig() {
                const mainExt = extensionList.length > 0 ? extensionList[0] : null;
                const mainIVR = ivrList.length > 0 ? ivrList[0] : null;

                return {
                    button1: {
                        label: mainExt ? `Ext ${mainExt.number}` : 'Extension',
                        dest: 'extension',
                        destValue: mainExt ? mainExt.id : '1'
                    },
                    button2: {
                        label: mainIVR ? mainIVR.name : 'End Call',
                        dest: mainIVR ? 'ivr' : 'end_call',
                        destValue: mainIVR ? mainIVR.id : ''
                    }
                };
            }

            window.configureQuickButtons = function(routeId) {
                const config = JSON.parse(localStorage.getItem(`quickButtons_${routeId}`)) || getDefaultButtonConfig();

                const modal = document.createElement('dialog');
                modal.className = 'modal';
                modal.innerHTML = `
                    <div class="modal-box">
                        <h3>Configure Quick Buttons for Route ${routeId}</h3>
                        <form id="quick-button-config-form">
                            <div style="margin-bottom: 1rem;">
                                <h4>Button 1</h4>
                                <div class="form-group">
                                    <label>Label</label>
                                    <input type="text" id="btn1-label" class="input" value="${config.button1.label}">
                                </div>
                                <div class="form-group">
                                    <label>Destination</label>
                                    <select id="btn1-dest" class="input">
                                        <option value="extension:${extensionList[0]?.id || '1'}" ${config.button1.dest === 'extension' ? 'selected' : ''}>Extension</option>
                                        <option value="ivr:${ivrList[0]?.id || '1'}" ${config.button1.dest === 'ivr' ? 'selected' : ''}>IVR</option>
                                        <option value="ext_vm:${extensionList[0]?.id || '1'}" ${config.button1.dest === 'ext_vm' ? 'selected' : ''}>Voicemail</option>
                                        <option value="end_call:" ${config.button1.dest === 'end_call' ? 'selected' : ''}>End Call</option>
                                    </select>
                                </div>
                            </div>
                            <div style="margin-bottom: 1rem;">
                                <h4>Button 2</h4>
                                <div class="form-group">
                                    <label>Label</label>
                                    <input type="text" id="btn2-label" class="input" value="${config.button2.label}">
                                </div>
                                <div class="form-group">
                                    <label>Destination</label>
                                    <select id="btn2-dest" class="input">
                                        <option value="extension:${extensionList[0]?.id || '1'}" ${config.button2.dest === 'extension' ? 'selected' : ''}>Extension</option>
                                        <option value="ivr:${ivrList[0]?.id || '1'}" ${config.button2.dest === 'ivr' ? 'selected' : ''}>IVR</option>
                                        <option value="ext_vm:${extensionList[0]?.id || '1'}" ${config.button2.dest === 'ext_vm' ? 'selected' : ''}>Voicemail</option>
                                        <option value="end_call:" ${config.button2.dest === 'end_call' ? 'selected' : ''}>End Call</option>
                                    </select>
                                </div>
                            </div>
                            <div class="modal-action">
                                <button type="submit" class="btn btn-primary">Save</button>
                                <button type="button" class="btn" onclick="this.closest('dialog').remove()">Cancel</button>
                            </div>
                        </form>
                    </div>
                `;

                document.body.appendChild(modal);
                modal.showModal();

                modal.querySelector('#quick-button-config-form').addEventListener('submit', (e) => {
                    e.preventDefault();

                    const [btn1Dest, btn1Value] = modal.querySelector('#btn1-dest').value.split(':');
                    const [btn2Dest, btn2Value] = modal.querySelector('#btn2-dest').value.split(':');

                    const newConfig = {
                        button1: {
                            label: modal.querySelector('#btn1-label').value,
                            dest: btn1Dest,
                            destValue: btn1Value
                        },
                        button2: {
                            label: modal.querySelector('#btn2-label').value,
                            dest: btn2Dest,
                            destValue: btn2Value
                        }
                    };

                    localStorage.setItem(`quickButtons_${routeId}`, JSON.stringify(newConfig));
                    loadQuickButtonConfig(routeId);
                    modal.remove();
                    alert('Button configuration saved!');
                });
            };

            window.executeQuickButton = async function(routeId, buttonNumber) {
                const config = JSON.parse(localStorage.getItem(`quickButtons_${routeId}`)) || getDefaultButtonConfig();
                const buttonConfig = buttonNumber === 1 ? config.button1 : config.button2;

                try {
                    // First, get the complete route details
                    console.log('Fetching route details for quick override...');
                    const routeDetails = await apiRequest(`inbound_route/get?id=${routeId}`);
                    
                    if (!routeDetails || routeDetails.errcode !== 0) {
                        throw new Error('Failed to fetch route details');
                    }

                    // Update the destination fields in the complete route object
                    const routeData = routeDetails.data;
                    const payload = {
                        ...routeData,  // Preserve all existing settings
                        id: parseInt(routeId),
                        def_dest: buttonConfig.dest,
                        def_dest_value: String(buttonConfig.destValue)
                    };

                    console.log('Updating route with payload:', payload);
                    const result = await apiRequest('inbound_route/update', 'POST', payload);
                    
                    if (result && result.errcode === 0) {
                        alert(`Route changed to: ${buttonConfig.label}`);
                        fetchAndRenderQuickOverride();
                    } else {
                        alert(`Failed to change route. Error: ${result ? result.errmsg : 'Unknown'}`);
                    }
                } catch (error) {
                    console.error('Quick button error:', error);
                    alert('Failed to change route: ' + error.message);
                }
            };

            // Route Switching System
            async function fetchAndRenderRouteSwitching() {
                setLoader('route-switching', true);
                const result = await apiRequest('inbound_route/list?page_size=100&sort_by=pos&order_by=asc');
                if (result && result.errcode === 0) {
                    renderRouteSwitching(result.data);
                } else {
                    renderRouteSwitching([]);
                }
                setLoader('route-switching', false);
            }

            function renderRouteSwitching(routes) {
                const container = document.getElementById('route-switching-content');
                container.innerHTML = '';

                if (!routes || routes.length === 0) {
                    container.innerHTML = '<p>No inbound routes found.</p>';
                    return;
                }

                console.log('Route switching - processing routes:', routes.length);

                // Group routes by DID pattern or similar criteria
                const routeGroups = groupRoutesByPattern(routes);
                console.log('Route switching - found groups:', Object.keys(routeGroups));

                Object.keys(routeGroups).forEach(pattern => {
                    const groupRoutes = routeGroups[pattern];
                    if (groupRoutes.length <= 1) return; // Skip single routes - no switching needed

                    const groupElement = document.createElement('div');
                    groupElement.style.backgroundColor = 'var(--color-base-200)';
                    groupElement.style.padding = '1rem';
                    groupElement.style.borderRadius = 'var(--radius)';
                    groupElement.style.marginBottom = '1rem';

                    // Find the currently active route (lowest position number)
                    const activeRoute = groupRoutes.reduce((prev, current) =>
                        (prev.pos < current.pos) ? prev : current
                    );

                    const routeButtons = groupRoutes.map(route => {
                        const isActive = route.id === activeRoute.id;
                        const dest = route.def_dest || route.default_destination;
                        const destValue = route.def_dest_value ||
                                         route.default_destination_value ||
                                         route.default_desination_value;
                        const destName = getCurrentDestinationName(dest, destValue);

                        return `
                            <button class="btn ${isActive ? 'btn-primary' : 'btn-secondary'} btn-sm"
                                    onclick="switchToRoute(${route.id}, '${pattern}')"
                                    ${isActive ? 'disabled' : ''}>
                                ${route.name} → ${destName}
                            </button>
                        `;
                    }).join('');

                    groupElement.innerHTML = `
                        <div style="margin-bottom: 1rem;">
                            <h4>Routes for: ${pattern}</h4>
                            <p style="font-size: 0.875rem; opacity: 0.7;">
                                Active: <strong>${activeRoute.name}</strong> (Position: ${activeRoute.pos})
                            </p>
                        </div>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            ${routeButtons}
                        </div>
                    `;
                    container.appendChild(groupElement);
                });

                if (Object.keys(routeGroups).length === 0) {
                    // Try an alternative grouping method based on route name similarity
                    const alternativeGroups = groupRoutesByNamePattern(routes);
                    if (Object.keys(alternativeGroups).length > 0) {
                        console.log('Using alternative name-based grouping:', alternativeGroups);
                        renderAlternativeRouteSwitching(container, alternativeGroups);
                    } else {
                        container.innerHTML = '<p>No route groups found for switching. You need multiple routes with the same DID pattern to use route switching.</p>';
                    }
                }
            }

            function groupRoutesByPattern(routes) {
                const groups = {};

                routes.forEach(route => {
                    console.log('Processing route for grouping:', {
                        name: route.name,
                        did_pattern_list: route.did_pattern_list,
                        did_patterns: route.did_patterns,
                        did_list: route.did_list,
                        patterns: route.patterns
                    });

                    // Try multiple possible field names for DID patterns
                    let didPatterns = route.did_pattern_list ||
                                     route.did_patterns ||
                                     route.did_list ||
                                     route.patterns;

                    let key;
                    if (didPatterns && Array.isArray(didPatterns) && didPatterns.length > 0) {
                        if (typeof didPatterns[0] === 'object' && didPatterns[0].pattern) {
                            key = didPatterns[0].pattern;
                        } else {
                            key = didPatterns[0];
                        }
                    } else if (didPatterns && typeof didPatterns === 'string') {
                        // Sometimes it might be a string instead of array
                        key = didPatterns;
                    } else {
                        // Fallback: group by route name pattern (if they follow a naming convention)
                        // or create a generic key for routes without DID patterns
                        key = `no-did-pattern-${route.name}`;
                    }

                    console.log('Grouping route', route.name, 'under key:', key);

                    if (!groups[key]) {
                        groups[key] = [];
                    }
                    groups[key].push(route);
                });

                console.log('All groups before filtering:', groups);

                // Only return groups with multiple routes
                const multiRouteGroups = {};
                Object.keys(groups).forEach(key => {
                    if (groups[key].length > 1) {
                        multiRouteGroups[key] = groups[key];
                        console.log('Found multi-route group:', key, 'with', groups[key].length, 'routes');
                    }
                });

                console.log('Final multi-route groups:', multiRouteGroups);
                return multiRouteGroups;
            }

            function groupRoutesByNamePattern(routes) {
                const groups = {};

                routes.forEach(route => {
                    // Look for routes with similar names (e.g., "In_0202_VM" and "In_0202")
                    // Extract base pattern from route name
                    let basePattern = route.name;

                    // Remove common suffixes to find base pattern
                    const suffixes = ['_VM', '_IVR', '_EXT', '_QUEUE', '_END'];
                    suffixes.forEach(suffix => {
                        if (basePattern.endsWith(suffix)) {
                            basePattern = basePattern.replace(suffix, '');
                        }
                    });

                    // Also try extracting number patterns (like 0202 from In_0202_VM)
                    const numberMatch = route.name.match(/(\d{3,})/);
                    if (numberMatch) {
                        basePattern = numberMatch[1]; // Use the number as the base pattern
                    }

                    console.log('Name-based grouping:', route.name, '→', basePattern);

                    if (!groups[basePattern]) {
                        groups[basePattern] = [];
                    }
                    groups[basePattern].push(route);
                });

                // Only return groups with multiple routes
                const multiRouteGroups = {};
                Object.keys(groups).forEach(key => {
                    if (groups[key].length > 1) {
                        multiRouteGroups[key] = groups[key];
                    }
                });

                return multiRouteGroups;
            }

            function renderAlternativeRouteSwitching(container, routeGroups) {
                Object.keys(routeGroups).forEach(pattern => {
                    const groupRoutes = routeGroups[pattern];

                    const groupElement = document.createElement('div');
                    groupElement.style.backgroundColor = 'var(--color-base-200)';
                    groupElement.style.padding = '1rem';
                    groupElement.style.borderRadius = 'var(--radius)';
                    groupElement.style.marginBottom = '1rem';

                    // Find the currently active route (lowest position number)
                    const activeRoute = groupRoutes.reduce((prev, current) =>
                        (prev.pos < current.pos) ? prev : current
                    );

                    const routeButtons = groupRoutes.map(route => {
                        const isActive = route.id === activeRoute.id;
                        const dest = route.def_dest || route.default_destination;
                        const destValue = route.def_dest_value ||
                                         route.default_destination_value ||
                                         route.default_desination_value;
                        const destName = getCurrentDestinationName(dest, destValue);

                        return `
                            <button class="btn ${isActive ? 'btn-primary' : 'btn-secondary'} btn-sm"
                                    onclick="switchToRoute(${route.id}, '${pattern}')"
                                    ${isActive ? 'disabled' : ''}>
                                ${route.name} → ${destName}
                            </button>
                        `;
                    }).join('');

                    groupElement.innerHTML = `
                        <div style="margin-bottom: 1rem;">
                            <h4>Route Group: ${pattern}</h4>
                            <p style="font-size: 0.875rem; opacity: 0.7;">
                                Active: <strong>${activeRoute.name}</strong> (Position: ${activeRoute.pos})
                            </p>
                        </div>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            ${routeButtons}
                        </div>
                    `;
                    container.appendChild(groupElement);
                });
            }

            window.switchToRoute = async function(targetRouteId, pattern) {
                console.log('🔀 SWITCH TO ROUTE CALLED:', { targetRouteId, pattern });
                
                try {
                    // First, get all routes to understand current positions
                    const routesResult = await apiRequest('inbound_route/list?page_size=100&sort_by=pos&order_by=asc');
                    console.log('📋 All routes fetched:', routesResult);
                    
                    if (!routesResult || routesResult.errcode !== 0) {
                        throw new Error('Failed to fetch routes for switching');
                    }

                    const routes = routesResult.data;
                    console.log('📍 All route positions:', routes.map(r => ({ id: r.id, name: r.name, pos: r.pos })));

                    // Try both grouping methods to find the route group
                    let routeGroups = groupRoutesByPattern(routes);
                    let groupRoutes = routeGroups[pattern];

                    if (!groupRoutes) {
                        // Try alternative name-based grouping
                        routeGroups = groupRoutesByNamePattern(routes);
                        groupRoutes = routeGroups[pattern];
                    }

                    if (!groupRoutes) {
                        console.error('Available route groups:', Object.keys(routeGroups));
                        console.error('Looking for pattern:', pattern);
                        throw new Error(`Route group '${pattern}' not found. Available groups: ${Object.keys(routeGroups).join(', ')}`);
                    }

                    console.log('Found route group for switching:', pattern, 'with routes:', groupRoutes.map(r => r.name));

                    // Find the target route
                    const targetRoute = groupRoutes.find(r => r.id === targetRouteId);
                    if (!targetRoute) {
                        throw new Error('Target route not found');
                    }

                    // Find the currently active route (lowest position in the group)
                    const currentActiveRoute = groupRoutes.reduce((prev, current) =>
                        (prev.pos < current.pos) ? prev : current
                    );

                    if (targetRoute.id === currentActiveRoute.id) {
                        alert('This route is already active');
                        return;
                    }

                    // Strategy: Make target route have the lowest position (most priority)
                    // Find the lowest position among all routes to ensure target becomes active
                    const allPositions = routes.map(r => r.pos);
                    const lowestPos = Math.min(...allPositions);
                    const newTargetPos = lowestPos - 1; // Make target route have even higher priority

                    console.log('Switching routes:', {
                        current: { name: currentActiveRoute.name, id: currentActiveRoute.id, pos: currentActiveRoute.pos },
                        target: { name: targetRoute.name, id: targetRoute.id, pos: targetRoute.pos },
                        newTargetPos: newTargetPos,
                        allPositions: allPositions
                    });

                    // First, get the complete route details for both routes to preserve all settings
                    console.log('Fetching complete route details for position swap...');
                    const [currentRouteDetails, targetRouteDetails] = await Promise.all([
                        apiRequest(`inbound_route/get?id=${currentActiveRoute.id}`),
                        apiRequest(`inbound_route/get?id=${targetRoute.id}`)
                    ]);

                    if (!currentRouteDetails || currentRouteDetails.errcode !== 0) {
                        throw new Error('Failed to fetch current route details');
                    }
                    if (!targetRouteDetails || targetRouteDetails.errcode !== 0) {
                        throw new Error('Failed to fetch target route details');
                    }

                    // Swap positions: target gets current's position, current gets target's position
                    console.log('Swapping route positions...');
                    const currentRouteData = currentRouteDetails.data;
                    const targetRouteData = targetRouteDetails.data;
                    
                    const currentOriginalPos = currentActiveRoute.pos;
                    const targetOriginalPos = targetRoute.pos;

                    // Update target route to have the current active route's position (higher priority)
                    const updateTargetPayload = {
                        ...targetRouteData,      // Preserve all existing settings
                        pos: currentOriginalPos  // Give it the current active's position
                    };

                    // Update current active route to have the target's original position (lower priority)
                    const updateCurrentPayload = {
                        ...currentRouteData,     // Preserve all existing settings
                        pos: targetOriginalPos   // Give it the target's original position
                    };

                    console.log('🔄 Updating routes:', {
                        targetRoute: { id: targetRoute.id, name: targetRoute.name, oldPos: targetOriginalPos, newPos: currentOriginalPos },
                        currentRoute: { id: currentActiveRoute.id, name: currentActiveRoute.name, oldPos: currentOriginalPos, newPos: targetOriginalPos }
                    });

                    console.log('📤 Target payload (first 200 chars):', JSON.stringify(updateTargetPayload).substring(0, 200));
                    console.log('📤 Current payload (first 200 chars):', JSON.stringify(updateCurrentPayload).substring(0, 200));

                    // Perform both updates
                    const [updateTargetResult, updateCurrentResult] = await Promise.all([
                        apiRequest('inbound_route/update', 'POST', updateTargetPayload),
                        apiRequest('inbound_route/update', 'POST', updateCurrentPayload)
                    ]);

                    console.log('📥 Target route update result:', updateTargetResult);
                    console.log('📥 Current route update result:', updateCurrentResult);

                    if (!updateTargetResult || updateTargetResult.errcode !== 0) {
                        console.error('❌ Failed to update target route:', updateTargetResult);
                        throw new Error(`Failed to update target route position: ${updateTargetResult ? updateTargetResult.errmsg : 'Unknown error'}`);
                    }

                    if (!updateCurrentResult || updateCurrentResult.errcode !== 0) {
                        console.error('❌ Failed to update current route:', updateCurrentResult);
                        throw new Error(`Failed to update current route position: ${updateCurrentResult ? updateCurrentResult.errmsg : 'Unknown error'}`);
                    }

                    console.log('✅ Both routes updated successfully!');

                    // Verify the change
                    const verifyResult = await apiRequest('inbound_route/list?page_size=100&sort_by=pos&order_by=asc');
                    console.log('🔍 Verifying new positions:', verifyResult.data.map(r => ({ id: r.id, name: r.name, pos: r.pos })));

                    alert(`✅ Successfully switched to route: ${targetRoute.name}\n\nCheck console for detailed verification.`);

                    // Refresh all route displays
                    fetchAndRenderRouteSwitching();
                    fetchAndRenderQuickOverride();

                } catch (error) {
                    console.error('Route switching error:', error);
                    alert(`Failed to switch route: ${error.message}`);
                }
            };

            // 4. Recent Calls
            let currentCallsPage = 1;
            async function fetchAndRenderRecentCalls(page = 1) {
                currentCallsPage = page;
                setLoader('recent-calls', true);
                const endpoint = `cdr/list?page_size=3&sort_by=time&order_by=desc&page=${page}`;
                const result = await apiRequest(endpoint);

                if (result && result.errcode === 0) {
                    renderRecentCalls(result.data, page);
                } else {
                    renderRecentCalls([], page);
                }
                setLoader('recent-calls', false);
                updatePaginationButtons(result);
            }

            function renderRecentCalls(calls, page) {
                const container = document.getElementById('recent-calls-content');
                container.innerHTML = '';
                if (calls.length === 0) {
                    container.innerHTML = '<p>No recent calls found.</p>';
                    return;
                }
                calls.forEach(call => {
                    const callElement = document.createElement('div');
                    callElement.style.backgroundColor = 'var(--color-base-200)';
                    callElement.style.padding = '0.75rem';
                    callElement.style.borderRadius = 'var(--radius)';
                    callElement.style.display = 'flex';
                    callElement.style.justifyContent = 'space-between';
                    callElement.style.alignItems = 'center';
                    callElement.innerHTML = `
                        <div>
                            <p>${call.call_from} -> ${call.call_to}</p>
                            <p style="font-size: 0.875rem; opacity: 0.7;">${call.time} - ${call.disposition} (${formatDuration(call.talk_duration)})</p>
                        </div>
                        <div>
                            <span class="badge ${getCallTypeBadge(call.call_type)}">${call.call_type}</span>
                        </div>
                    `;
                    container.appendChild(callElement);
                });
                document.getElementById('page-info').textContent = `Page ${page}`;
            }
            
            function updatePaginationButtons(result) {
                const prevBtn = document.getElementById('prev-calls');
                const nextBtn = document.getElementById('next-calls');
                const pageInfo = document.getElementById('page-info');
                prevBtn.disabled = currentCallsPage <= 1;
                nextBtn.disabled = !result || result.data.length < 3;  // Assume no more if < page_size
                // Note: For full pagination, we'd need total count from API; this is simple heuristic
            }

            document.getElementById('prev-calls').addEventListener('click', () => {
                if (currentCallsPage > 1) fetchAndRenderRecentCalls(currentCallsPage - 1);
            });
            document.getElementById('next-calls').addEventListener('click', () => {
                fetchAndRenderRecentCalls(currentCallsPage + 1);
            });

            // --- UTILITY FUNCTIONS ---
            function formatTrunkStatus(status) {
                const statusMap = { 0: 'Idle', 1: 'Busy', 2: 'Ringing', 3: 'Dialing', 4: 'Unavailable', 5: 'Registering', 6: 'Registered', 7: 'Unregistered', 8: 'Failed', 9: 'Authenticating', 10: 'Connecting' };
                return statusMap[status] || 'Unknown';
            }

            function getTrunkStatusBadge(status) {
                 switch (status) {
                    case 6: return 'badge-success';
                    case 0: return 'badge-info';
                    case 1: return 'badge-warning';
                    case 8: return 'badge-error';
                    default: return 'badge-ghost';
                }
            }

            function setLoader(type, isLoading) {
                const loader = document.getElementById(`${type}-loader`);
                const content = document.getElementById(`${type}-content`);
                if (!loader || !content) return; 
                if (isLoading) {
                    loader.classList.remove('hidden');
                    content.classList.add('hidden');
                } else {
                    loader.classList.add('hidden');
                    content.classList.remove('hidden');
                }
            }

            function formatDuration(seconds) {
                if (seconds === null || seconds === undefined) return '0s';
                if (seconds < 60) return `${seconds}s`;
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                return `${minutes}m ${remainingSeconds}s`;
            }

            function getCallTypeBadge(type) {
                if (!type) return 'badge-ghost';
                switch (type.toLowerCase()) {
                    case 'inbound': return 'badge-success';
                    case 'outbound': return 'badge-info';
                    case 'internal': return 'badge-warning';
                    default: return 'badge-ghost';
                }
            }

            // --- PWA Service Worker ---
            // function registerServiceWorker() {
            //     if ('serviceWorker' in navigator) {
            //         const swContent = `
            //             const CACHE_NAME = 'yeastar-dashboard-cache-v2';
            //             const urlsToCache = ['./index.html', './style.css'];
            //             self.addEventListener('install', event => { event.waitUntil( caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache)) ); });
            //             self.addEventListener('activate', event => { const cacheWhitelist = [CACHE_NAME]; event.waitUntil( caches.keys().then(cacheNames => Promise.all( cacheNames.map(cacheName => { if (cacheWhitelist.indexOf(cacheName) === -1) { return caches.delete(cacheName); } }) )) ); });
            //             self.addEventListener('fetch', event => { if (event.request.url.startsWith('http')) { event.respondWith( caches.open(CACHE_NAME).then(cache => cache.match(event.request).then(response => { const fetchPromise = fetch(event.request).then(networkResponse => { if (!event.request.url.includes('/openapi/v1.0/')) { cache.put(event.request, networkResponse.clone()); } return networkResponse; }); return response || fetchPromise; })) ); } });
            //         `;
            //         const blob = new Blob([swContent], {type: 'application/javascript'});
            //         const swUrl = URL.createObjectURL(blob);
            //         navigator.serviceWorker.register(swUrl).then(reg => console.log('SW reg success', reg)).catch(err => console.log('SW reg failed', err));
            //     }
            // }

            // function setupManifest() {
            //      const manifest = {
            //         "name": "Yeastar PBX Dashboard", "short_name": "PBX Dash", "start_url": ".", "display": "standalone", "background_color": "#ffffff", "theme_color": "#ffffff",
            //         "icons": [ { "src": "https://placehold.co/192x192/3498db/FFFFFF?text=PBX", "sizes": "192x192", "type": "image/png" }, { "src": "https://placehold.co/512x512/3498db/FFFFFF?text=PBX", "sizes": "512x512", "type": "image/png" } ]
            //     };
            //     const blob = new Blob([JSON.stringify(manifest)], {type: 'application/json'});
            //     const manifestURL = URL.createObjectURL(blob);
            //     document.querySelector('link[rel="manifest"]').setAttribute('href', manifestURL);
            // }

            // --- INITIALIZATION ---
            // setupManifest();
            // registerServiceWorker();

            // --- EVENT LISTENERS ---
            connectBtn.addEventListener('click', async () => {
                proxyUrl = proxyUrlInput.value.trim();
                pbxHost = pbxHostInput.value.trim();
                const clientId = clientIdInput.value.trim();
                const clientSecret = clientSecretInput.value.trim();

                if (!proxyUrl || !pbxHost || !clientId || !clientSecret) {
                    alert('Please fill in all API configuration fields.');
                    return;
                }
                
                sessionStorage.removeItem('yeastar_accessToken');
                accessToken = null;

                const initialAccessToken = await getAccessToken(pbxHost, clientId, clientSecret);
                if (initialAccessToken) {
                    accessToken = initialAccessToken;
                    apiConfigSection.classList.add('hidden');
                    dashboardContent.classList.remove('hidden');
                    
                    const extensionIds = await fetchAllExtensions();
                    
                    if(extensionIds) {
                        Promise.all([
                            fetchAndRenderStats(extensionIds),
                            fetchAndRenderQuickOverride(),
                            fetchAndRenderRouteSwitching(),
                            fetchAndRenderRecentCalls(1)
                        ]);
                    }

                    if (extensionIds.length > 0 && accessToken) {
                        // Polling for live sections (every 10 seconds)
                        setInterval(() => {
                            // fetchAndRenderRecentCalls(1); // Polling for recent calls
                        }, 10000);  // 10 seconds
                    }
                }
            });
            
            saveConfigBtn.addEventListener('click', () => {
                const config = {
                    proxyUrl: proxyUrlInput.value.trim(),
                    host: pbxHostInput.value.trim(),
                    clientId: clientIdInput.value.trim(),
                    clientSecret: clientSecretInput.value.trim()
                };
                if(config.proxyUrl && config.host && config.clientId && config.clientSecret) {
                    localStorage.setItem('yeastarConfig', JSON.stringify(config));
                    alert('Configuration saved to your browser\'s local storage.');
                } else {
                    alert('Please fill all fields before saving.');
                }
            });

            document.getElementById('refresh-recent').addEventListener('click', () => fetchAndRenderRecentCalls(currentCallsPage));
        });
    </script>
</body>
</html>
